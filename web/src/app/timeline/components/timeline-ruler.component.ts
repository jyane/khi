/**
 * Copyright 2026 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { CommonModule } from '@angular/common';
import {
  AfterViewInit,
  Component,
  computed,
  DestroyRef,
  ElementRef,
  inject,
  input,
  model,
  NgZone,
  output,
  viewChild,
} from '@angular/core';
import { TimelineRulerRenderer as TimelineRulerCanvasRenderer } from './canvas/timeline-ruler-renderer';
import { MatIconModule } from '@angular/material/icon';
import { KHIIconRegistrationModule } from 'src/app/shared/module/icon-registration.module';
import { RenderingLoopManager } from './canvas/rendering-loop-manager';
import { TimelineRulerViewModel } from './timeline-ruler.viewmodel';
import { generateDefaultRulerStyle } from './style-model';

interface DateLabel {
  offsetX: number;
  labelLeft: string;
  labelRight: string;
}

/**
 * Component that renders the timeline ruler, displaying time ticks and date labels.
 *
 * This component combines a Canvas-based renderer (`TimelineRulerCanvasRenderer`) for high-performance
 * tick rendering and standard Angular template bindings for date labels. It synchronizes with the
 * `RenderingLoopManager` to ensure smooth animations during scrolling and zooming.
 */
@Component({
  selector: 'khi-timeline-ruler',
  imports: [CommonModule, MatIconModule, KHIIconRegistrationModule],
  templateUrl: './timeline-ruler.component.html',
  styleUrls: ['./timeline-ruler.component.scss'],
})
export class TimelineRulerComponent implements AfterViewInit {
  private readonly container =
    viewChild<ElementRef<HTMLDivElement>>('container');
  private readonly backgroundCanvas =
    viewChild<ElementRef<HTMLCanvasElement>>('backgroundCanvas');

  private readonly ngZone = inject(NgZone);

  private readonly destroyRef = inject(DestroyRef);

  private readonly renderingLoopManager = inject(RenderingLoopManager);

  /**
   * The timezone offset in hours to apply to the displayed time.
   * Positive values move ahead of UTC, negative values move behind.
   */
  timezoneShift = input(0);

  /**
   * The view model containing the calculated tick marks and hierarchy for the ruler.
   * This is typically generated by `RulerViewModelCalculator`.
   */
  viewModel = input.required<TimelineRulerViewModel>();

  /**
   * Configuration for the visual style of the ruler, such as colors and dimensions.
   */
  rulerStyle = input(generateDefaultRulerStyle());

  /**
   * The timestamp (in milliseconds) corresponding to the visible left edge of the timeline.
   */
  leftEdgeTime = input<number>(0);

  /**
   * The current zoom level, expressed as pixels per millisecond.
   */
  pixelsPerMs = input<number>(1);

  /**
   * Emits when the scaling mode is changed.
   */
  scalingMode = model<boolean>();

  /**
   * Emits when the ruler is scrolled.
   */
  scrollOnRuler = output<WheelEvent>();

  /**
   * Computes the positions and text for date labels (e.g., "YYYY/MM/DD") based on the current
   * visible time range, ensuring that day boundaries are correctly labeled.
   */
  dateLabels = computed(() => {
    const viewModel = this.viewModel();
    const leftEdgeTime = this.leftEdgeTime();
    const pixelsPerMs = this.pixelsPerMs();
    const labels: DateLabel[] = [];
    const DAY = 60 * 60 * 24 * 1000;
    const timezoneShiftInMs = this.timezoneShift() * 60 * 60 * 1000;
    const currentTimeWithTimezoneShift = leftEdgeTime - timezoneShiftInMs;
    let prevDayTime = Math.floor(currentTimeWithTimezoneShift / DAY) * DAY;
    while (true) {
      const currentDayTime = prevDayTime + DAY;
      if (
        currentDayTime >
        leftEdgeTime + viewModel.tickTimeMS * viewModel.histogramBuckets.length
      ) {
        break;
      }
      labels.push({
        offsetX: (currentDayTime - leftEdgeTime) * pixelsPerMs,
        labelLeft: this.toDateLabel(currentDayTime - timezoneShiftInMs - DAY),
        labelRight: this.toDateLabel(currentDayTime - timezoneShiftInMs),
      });
      prevDayTime = currentDayTime;
    }
    return labels;
  });

  private rulerCanvasRenderer!: TimelineRulerCanvasRenderer;

  private resizeObserver: ResizeObserver | null = null;

  /**
   * Initializes the canvas renderer, registers the render loop handler,
   * and sets up the resize observer to handle window or container resizing.
   */
  ngAfterViewInit(): void {
    const backgroundCanvas = this.backgroundCanvas()!.nativeElement;
    const backgroundCtx = backgroundCanvas.getContext('2d', {
      colorSpace: 'display-p3',
    });
    if (!backgroundCtx) {
      alert(
        `Failed to get canvas 2D context. Please try reload this page or restart your computer.`,
      );
      return;
    }
    this.rulerCanvasRenderer = new TimelineRulerCanvasRenderer(backgroundCtx);

    this.renderingLoopManager.registerRenderHandler(this.destroyRef, () => {
      this.rulerCanvasRenderer.render(
        this.viewModel(),
        this.leftEdgeTime(),
        this.pixelsPerMs(),
      );
    });

    this.resizeObserver = new ResizeObserver(() => {
      this.ngZone.runOutsideAngular(() => {
        this.handleResize();
      });
    });
    this.resizeObserver.observe(this.container()!.nativeElement);
    this.destroyRef.onDestroy(() => {
      this.resizeObserver?.disconnect();
    });

    this.ngZone.runOutsideAngular(() => {
      const onWheel = (event: WheelEvent) => {
        event.preventDefault();
        event.stopPropagation();

        this.scrollOnRuler.emit(event);
      };
      this.container()!.nativeElement.addEventListener('wheel', onWheel, {
        passive: false,
      });
      this.destroyRef.onDestroy(() => {
        this.container()!.nativeElement.removeEventListener('wheel', onWheel);
      });
    });
  }

  /**
   * Handles resize events by updating the canvas dimensions to match the container.
   * The actual resize operation is deferred to the next render frame to avoid
   * flickering and to ensure it runs in the appropriate context.
   */
  private handleResize() {
    const container = this.container()!.nativeElement;
    const canvas = this.backgroundCanvas()!.nativeElement;
    const style = this.rulerStyle();
    const dpr = window.devicePixelRatio || 1;
    canvas.style.width = `${container.clientWidth}px`;
    canvas.style.height = `${style.headerHeightInPx}px`;

    // Changing actual canvas size or notifying resizes to the renderer may clear the canvas and cause the flickering effect.
    // Delay its actual resizing on the next rendering time.
    this.renderingLoopManager.registerOnceBeforeRenderHandler(() => {
      canvas.width = container.clientWidth * dpr;
      canvas.height = style.headerHeightInPx * dpr;
      this.rulerCanvasRenderer.resize(canvas.width, canvas.height, dpr);
    });
  }

  /**
   * Formats a timestamp into a date string (YYYY/MM/DD) according to the configured timezone shift.
   */
  private toDateLabel(time: number): string {
    const date = new Date(time + this.timezoneShift() * 60 * 60 * 1000);
    const year = date.getUTCFullYear();
    const month = ('' + (date.getUTCMonth() + 1)).padStart(2, '0');
    const day = ('' + date.getUTCDate()).padStart(2, '0');
    return `${year}/${month}/${day}`;
  }

  mouseEnter() {
    this.scalingMode.set(true);
  }

  mouseLeave() {
    this.scalingMode.set(false);
  }
}
